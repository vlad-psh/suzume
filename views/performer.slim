h1
  = @performer.title
  span< style="font-size: 0.5em": a href=path_to(:artist).with(@performer.old_id) orig
div style="opacity: 0.5" = Artist.find(@performer.old_id).tagsstr
== slim :tags_form, locals: {performer: @performer}
br

h2 Records
- ratings = %w(ðŸ™‚ ðŸµ ðŸ’Ž)
- prev_release = 0
- @performer.sorted_records.reverse.each do |r|
  - if r.release_id != prev_release
    div.hr-title
      span
        - if r.release.download_cover
          a class="cover-link" href=r.release.download_cover = r.release.title
        - else
          = r.release.title
    span< style="font-weight: normal; opacity: 0.5" = Album.find(r.release.old_id).tagsstr
    - prev_release = r.release_id
  li
    a.ajax-link.track-playback-link data-track-url=r.download_path href=r.download_path = "##{r.id} #{ratings[r.rating]} #{r.original_filename}"
    span< style="opacity: 0.5" = Track.find(r.old_id).tagsstr
    span< == "| #{mediainfo(r.mediainfo)}"

h2 Releases
ul.releases-list
  - @performer.releases.order(title: :asc).each do |r|
    li = r.title

div#tulip-player
  div#progress-bar
    div#progress-bar-current
  a#pause-button pause
  audio#main-player preload="none" controls="controls" style="width: 500px"

javascript:
  var playlist = [];
  var playIndex = 0;
  var player = $('#main-player')[0];
  var progressUpdateInterval;

  function startUpdateProgress(){
    if (!progressUpdateInterval){
      progressUpdateInterval = setInterval(updateProgress, 500);
    }
  };

  function stopUpdateProgress(){
    if (progressUpdateInterval){
      clearInterval(progressUpdateInterval);
      progressUpdateInterval = undefined;
    }
  };

  function updateProgress(){
    var hPercent = (player.currentTime / player.duration * 100).toFixed(4);
    $('#progress-bar-current').css('width', hPercent + '%');
    //console.log(percent);
  };

  function progressBarPercents(event){
    var percent = event.pageX / $('#progress-bar').width();
    if (percent > 100){ percent = 100; }
    return percent;
  };

  var seekProgressMove = function(event){
    $('#progress-bar-current').css('width', progressBarPercents(event) * 100 + '%');
    //console.log("mousemove: " + event.pageX);
  };

  var seekProgressMouseUp = function(event){
    event.preventDefault();
    //console.log("mouseup: " + event.screenX);

    $(document).off('mouseup', seekProgressMouseUp);
    $(document).off('mousemove', seekProgressMove);

    player.currentTime = progressBarPercents(event) * player.duration;

    startUpdateProgress();
  };

  $(document).on('mousedown', '#progress-bar', function(event){
    if (!player.paused){
      event.preventDefault();
      //console.log("mousedown: " + event.pageX);

      stopUpdateProgress();
      $('#progress-bar-current').css('width', progressBarPercents(event) * 100 + '%');

      $(document).on('mouseup', '', seekProgressMouseUp);
      $(document).on('mousemove', seekProgressMove);
    }
  });

  $(document).on('click', '#pause-button', function(){
    if (player.paused){
      player.play();
      startUpdateProgress();
    } else {
      player.pause();
      stopUpdateProgress();
    }
  });

  $(document).on('click', '.toggle-link', function(){
    var target = $(this).data('target');
    $(target).toggle();
  });

  $(document).on('click', '.track-playback-link', function(event){
    event.preventDefault();

    var track_url = $(this).data('track-url');
    playlist = [];
    $('.track-playback-link').each(function(){
      var url = $(this).data('track-url');
      playlist.push(url);
      console.log(url);
      if (url == track_url) {
        playIndex = playlist.length - 1;
      }
    });
    
    play();
  });

  function play(){
    $(player).attr('src', playlist[playIndex]);
    player.play();
    startUpdateProgress();
    $('.track-now-playing').removeClass('track-now-playing');
    $('.track-playback-link').each(function(){
      if ($(this).data('track-url') == playlist[playIndex]) {
        $(this).addClass('track-now-playing')
      }
    });
  }

  $('#main-player').on('ended', function(){
    playIndex = playIndex + 1;
    if (playIndex < playlist.length) {
      player.currentTime = 0;
      play();
    } else {
      stopUpdateProgress();
    }
  });
